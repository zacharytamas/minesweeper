<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <script src="../../webcomponentsjs/webcomponents.min.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <link rel="import" href="../mine-cell.html">
</head>
<body>

<script>


  describe('<mine-cell>', function() {

    var cell = document.createElement('mine-cell');

    var getNewCell = function getNewCell() {
      cell = document.createElement('mine-cell');
    };

    describe('Properties', function() {
      it('should have a `covered` property which is true by default', function() {
        expect(cell.covered).to.exist.and.to.be.true;
      });

      it('should have a `flagged` property which is false by default', function() {
        expect(cell.flagged).to.exist.and.to.be.false;
      })

      it('should have a `mine` property which is false by default', function() {
        expect(cell.mine).to.exist.and.to.be.false;
      });

      it('should have an `adjacentMines` property which is 0 by default', function() {
        expect(cell.adjacentMines).to.exist.and.to.equal(0);
      });
    });

    describe('Public methods', function() {
      it('should have a `toggleFlag()` method', function() {
        expect(cell.toggleFlag).to.exist.and.to.be.a('function');
      });

      it('should have an `uncover()` method', function() {
        expect(cell.uncover).to.exist.and.to.be.a('function');
      })
    });

    describe('Calling toggleFlag()', function() {

      beforeEach(getNewCell);

      context('When cell is covered', function() {
        it('should flag cell if it was nonflagged', function() {
          expect(cell.flagged).to.be.false;  // sanity
          cell.toggleFlag();
          expect(cell.flagged).to.be.true;
        });

        it('should unflag a cell if it was flagged', function() {
          cell.flagged = true;
          cell.toggleFlag();
          expect(cell.flagged).to.be.false;
        });

        it('should fire a `flagged` event if the cell was flagged', function() {
          // Cell is flagged=false by default, so calling toggleFlag() on it
          // should cause it to become flagged and trigger a `flagged` event.
          sinon.spy(cell, 'fire');
          cell.toggleFlag();
          expect(cell.fire).to.have.been.calledWith('flagged');
        });

        it('should fire an `unflagged` event if the cell was unflagged', function() {
          sinon.spy(cell, 'fire');
          cell.flagged = true;
          cell.toggleFlag();
          expect(cell.fire).to.have.been.calledWith('unflagged');
        });
      });

      context('When cell is uncovered', function() {

        beforeEach(function() {
          cell.covered = false;
        });

        it('should be an inert action, not affecting flagged property', function() {
          // If a cell has been uncovered it cannot be flagged anymore.
          expect(cell.flagged).to.be.false;
          cell.toggleFlag();
          // Should still be false.
          expect(cell.flagged).to.be.false;
        });

        it('should not fire flagging events', function() {
          sinon.spy(cell, 'fire');
          cell.toggleFlag();
          cell.toggleFlag();
          expect(cell.fire).to.not.have.been.called;
        });
      });
    });

    describe('Calling uncover()', function() {

      beforeEach(getNewCell);

      context('When cell is covered', function() {
        it('should update covered property', function() {
          expect(cell.covered).to.be.true;
          cell.uncover();
          expect(cell.covered).to.be.false;
        });

        it('should fire an `uncovered` event', function() {
          sinon.spy(cell, 'fire');
          cell.uncover();
          expect(cell.fire).to.have.been.calledWith('uncovered');
        });

        context('When cell is also a mine', function() {
          it('should explode!', function() {
            sinon.spy(cell, 'fire');

            cell.mine = true;
            cell.uncover();

            expect(cell.fire).to.have.been.calledWith('exploded');
          });
        });

        context('When cell is also flagged', function() {

          // These tests test that the uncover() method basically does nothing
          // if the cell is flagged. If a cell is flagged the user cannot
          // interact with it until they unflag it. This means that you cannot
          // accidentally explode a mine you already flagged as a mine.

          beforeEach(function() {
            cell.toggleFlag();
          });

          it('should not fire any events', function() {
            sinon.spy(cell, 'fire');
            cell.uncover();
            expect(cell.fire).to.not.have.been.called;
          });

          it('should not affect the `covered` property', function() {
            cell.uncover();
            // It should still be covered, even though we attempted to
            // uncover it.
            expect(cell.covered).to.be.true;
          });
        });
      });

      context('When cell is uncovered', function() {

        beforeEach(function() {
          cell.covered = false;
        });

        it('should not change covered property', function() {
          expect(cell.covered).to.be.false;
          cell.uncover();
          expect(cell.covered).to.be.false;
        });

        it('should not emit an `uncovered` event', function() {
          sinon.spy(cell, 'fire');
          cell.uncover();
          expect(cell.fire).to.not.have.been.called;
        });
      });
    });

    describe('User interactions', function() {

    });

    describe('Appearance', function() {

      beforeEach(getNewCell);

      describe('The `adjacent` element', function() {

        it('Should have an element with id `adjacent` in its local dom.', function() {
          expect(cell.$.adjacent).to.exist;
        });

        it('should show the correct number based on adjacentMines', function() {
          _.each([0, 1, 2, 3, 4, 5, 6, 7, 8], function(val) {
            cell.adjacentMines = val;
            expect(cell.$.adjacent.innerText).to.equal(String(val));
          });
        });

        it('should hide when the cell is covered or has no adjacent mines', function() {
          // Case 1: Cell is covered
          expect(cell.covered).to.be.true;
          expect(cell.$.adjacent.hasAttribute('hidden')).to.be.true;

          // Case 2: Cell is uncovered but has no adjacent mines, so it
          // should be hidden still.
          cell.uncover();
          expect(cell.adjacentMines).to.equal(0);
          expect(cell.$.adjacent.hasAttribute('hidden')).to.be.true;

          // Case 3: Cell is uncovered and has adjacent mines, thus should
          // NOT be hidden.
          cell.adjacentMines = 2;
          expect(cell.$.adjacent.hasAttribute('hidden')).to.not.be.true;

        });

      })
    });

  });

</script>

</body>
</html>
