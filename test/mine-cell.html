<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <script src="../../webcomponentsjs/webcomponents.min.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <link rel="import" href="../mine-cell.html">
</head>
<body>

<script>


  describe('<mine-cell>', function() {

    var cell = document.createElement('mine-cell');

    var getNewCell = function() {
      cell = document.createElement('mine-cell');
    };

    describe('Properties', function() {
      it('should have a `covered` property which is true by default', function() {
        expect(cell.covered).to.exist.and.to.be.true;
      });

      it('should have a `flagged` property which is false by default', function() {
        expect(cell.flagged).to.exist.and.to.be.false;
      })

      it('should have a `mine` property which is false by default', function() {
        expect(cell.mine).to.exist.and.to.be.false;
      });
    });

    describe('Public methods', function() {
      it('should have a `toggleFlag()` method', function() {
        expect(cell.toggleFlag).to.exist.and.to.be.a('function');
      });

      it('should have an `uncover()` method', function() {
        expect(cell.uncover).to.exist.and.to.be.a('function');
      })
    });

    describe('API: toggleFlag()', function() {

      beforeEach(getNewCell);

      context('When cell is covered', function() {
        it('should flag cell if it was nonflagged', function() {
          expect(cell.flagged).to.be.false;  // sanity
          cell.toggleFlag();
          expect(cell.flagged).to.be.true;
        });

        it('should unflag a cell if it was flagged', function() {
          cell.flagged = true;
          cell.toggleFlag();
          expect(cell.flagged).to.be.false;
        });

        it('should fire a `flagged` event if the cell was flagged', function() {
          // Cell is flagged=false by default, so calling toggleFlag() on it
          // should cause it to become flagged and trigger a `flagged` event.
          sinon.spy(cell, 'fire');
          cell.toggleFlag();
          expect(cell.fire).to.have.been.calledWith('flagged');
        });

        it('should fire an `unflagged` event if the cell was unflagged', function() {
          sinon.spy(cell, 'fire');
          cell.flagged = true;
          cell.toggleFlag();
          expect(cell.fire).to.have.been.calledWith('unflagged');
        });
      });

      context('When cell is uncovered', function() {

        beforeEach(function() {
          cell.covered = false;
        });

        it('should be an inert action, not affecting flagged property', function() {
          // If a cell has been uncovered it cannot be flagged anymore.
          expect(cell.flagged).to.be.false;
          cell.toggleFlag();
          // Should still be false.
          expect(cell.flagged).to.be.false;
        });

        it('should not fire flagging events', function() {
          sinon.spy(cell, 'fire');
          cell.toggleFlag();
          cell.toggleFlag();
          expect(cell.fire).to.not.have.been.called;
        });
      });
    });

    describe('API: uncover()', function() {

      beforeEach(getNewCell);

      context('When cell is covered', function() {
        it('should update covered property', function() {
          expect(cell.covered).to.be.true;
          cell.uncover();
          expect(cell.covered).to.be.false;
        });

        it('should fire an `uncovered` event', function() {
          sinon.spy(cell, 'fire');
          cell.uncover();
          expect(cell.fire).to.have.been.calledWith('uncovered');
        });
      });

      context('When cell is uncovered', function() {

        beforeEach(function() {
          cell.covered = false;
        });

        it('should not change covered property', function() {
          expect(cell.covered).to.be.false;
          cell.uncover();
          expect(cell.covered).to.be.false;
        });

        it('should not emit an `uncovered` event', function() {
          sinon.spy(cell, 'fire');
          cell.uncover();
          expect(cell.fire).to.not.have.been.called;
        });
      });
    });

    describe('User interactions', function() {

    });

  });

</script>

</body>
</html>
